cmake_minimum_required(VERSION 3.2.3)
project(RHash)
#Do not prefix BUILD_SHARED_LIBS and BUILD_STATIC_LIBS because those are standard cmake options
#We only put them in the menu for convenience.
option(BUILD_SHARED_LIBS "Build shared LibRHash libraries" ON)
option(BUILD_STATIC_LIBS "Build static LibRHash libraries" ON)

option(RHASH_USE_OPENSSL "Build Rhash with OpenSSL Crypto support" ON)
option(RHASH_OPENSSL_RUNTIME "load OpenSSL at runtime if present" ON)
option(RHASH_BUILD_EXE "Build rhash executable" ON)
option(RHASH_USE_GETTEXT "Build rhash executable with i18n support with gettext" ON)
option(RHASH_BUILD_LIB_DOCS "Build libRhash documentation with Doxygen" ON)
option(RHASH_WITH_PKGCONFIG_SUPPORT "Generate and install .pc files" ON)
option(RHASH_INCLUDE_WINDIST_FILES "Include Windows distribution files" ON)
option(RHASH_INCLUDE_OTHER_FILES "Include other files from the distribution" ON)
option(RHASH_TESTS_OPT_FULL "Run rhash executable all hash options test" ON)

enable_testing()
include( CTest )

include(GNUInstallDirs)
include(FindPkgConfig)
if(RHASH_USE_OPENSSL)
  include(FindOpenSSL)
endif(RHASH_USE_OPENSSL)
if(RHASH_BUILD_EXE)
  include(FindGettext)
  include(FindIntl)
endif(RHASH_BUILD_EXE)
if(RHASH_BUILD_LIB_DOCS)
  include(FindDoxygen)
endif(RHASH_BUILD_LIB_DOCS)

set(SOVERSION 0)

# Do things this way instead of using relative ../ reference
# so that the builder's path does not appear in diagrams created by DOT
# or any documentation generated by Doxygen.  We don't want that to appear
# in any packages that are for redistribution.
get_filename_component(RHASH_SRC_DIR ${CMAKE_CURRENT_LIST_DIR}/.. REALPATH)
set(RHASH_BUILD_DIR ${CMAKE_CURRENT_BINARY_DIR})
set(RHASH_LIB_DIR   ${RHASH_SRC_DIR}/librhash)
set(RHASH_LIB_HEADERS 
	${RHASH_LIB_DIR}/algorithms.h
	${RHASH_LIB_DIR}/byte_order.h
	${RHASH_LIB_DIR}/plug_openssl.h
	${RHASH_LIB_DIR}/rhash.h 
	${RHASH_LIB_DIR}/rhash_timing.h
	${RHASH_LIB_DIR}/rhash_torrent.h
	${RHASH_LIB_DIR}/aich.h
	${RHASH_LIB_DIR}/crc32.h
	${RHASH_LIB_DIR}/ed2k.h
	${RHASH_LIB_DIR}/edonr.h
	${RHASH_LIB_DIR}/hex.h
	${RHASH_LIB_DIR}/md4.h 
	${RHASH_LIB_DIR}/md5.h
	${RHASH_LIB_DIR}/sha1.h
	${RHASH_LIB_DIR}/sha256.h
	${RHASH_LIB_DIR}/sha512.h 
	${RHASH_LIB_DIR}/sha3.h
	${RHASH_LIB_DIR}/ripemd-160.h 
	${RHASH_LIB_DIR}/gost.h
	${RHASH_LIB_DIR}/has160.h
	${RHASH_LIB_DIR}/snefru.h
	${RHASH_LIB_DIR}/tiger.h
	${RHASH_LIB_DIR}/tth.h
	${RHASH_LIB_DIR}/torrent.h
	${RHASH_LIB_DIR}/ustd.h
	${RHASH_LIB_DIR}/util.h
	${RHASH_LIB_DIR}/whirlpool.h)

set(RHASH_LIB_SOURCES 
	${RHASH_LIB_DIR}/algorithms.c
	${RHASH_LIB_DIR}/byte_order.c
	${RHASH_LIB_DIR}/plug_openssl.c
	${RHASH_LIB_DIR}/rhash.c
	${RHASH_LIB_DIR}/rhash_timing.c
	${RHASH_LIB_DIR}/rhash_torrent.c
	${RHASH_LIB_DIR}/aich.c
	${RHASH_LIB_DIR}/crc32.c
	${RHASH_LIB_DIR}/ed2k.c
	${RHASH_LIB_DIR}/edonr.c
	${RHASH_LIB_DIR}/hex.c
	${RHASH_LIB_DIR}/md4.c
	${RHASH_LIB_DIR}/md5.c
	${RHASH_LIB_DIR}/sha1.c
	${RHASH_LIB_DIR}/sha256.c
	${RHASH_LIB_DIR}/sha512.c
	${RHASH_LIB_DIR}/sha3.c
	${RHASH_LIB_DIR}/ripemd-160.c
	${RHASH_LIB_DIR}/gost.c
	${RHASH_LIB_DIR}/has160.c
	${RHASH_LIB_DIR}/snefru.c
	${RHASH_LIB_DIR}/tiger.c
	${RHASH_LIB_DIR}/tiger_sbox.c
	${RHASH_LIB_DIR}/tth.c
	${RHASH_LIB_DIR}/torrent.c
	${RHASH_LIB_DIR}/whirlpool.c
	${RHASH_LIB_DIR}/whirlpool_sbox.c)
set(RHASH_LIB_PUBLIC_HEADERS 
	${RHASH_LIB_DIR}/rhash.h
	${RHASH_LIB_DIR}/rhash_torrent.h)
set(RHASH_LIB_TEXT_SOURCES 
        ${RHASH_LIB_DIR}/test_hashes.c
        ${RHASH_LIB_DIR}/test_hashes.h)
set(RHASH_LIB_DEPEND_LIBS "")
set(RHASH_EXE_HEADERS 
	${RHASH_SRC_DIR}/calc_sums.h 
	${RHASH_SRC_DIR}/hash_print.h
	${RHASH_SRC_DIR}/common_func.h
	${RHASH_SRC_DIR}/hash_update.h
	${RHASH_SRC_DIR}/file.h
	${RHASH_SRC_DIR}/file_mask.h 
	${RHASH_SRC_DIR}/file_set.h 
	${RHASH_SRC_DIR}/find_file.h 
	${RHASH_SRC_DIR}/hash_check.h 
	${RHASH_SRC_DIR}/output.h 
	${RHASH_SRC_DIR}/parse_cmdline.h 
	${RHASH_SRC_DIR}/rhash_main.h 
	${RHASH_SRC_DIR}/win_utils.h 
	${RHASH_SRC_DIR}/platform.h 
	${RHASH_SRC_DIR}/version.h)
set(RHASH_WIN_BAT_FILES 
	${RHASH_SRC_DIR}/dist/MD5.bat
	${RHASH_SRC_DIR}/dist/magnet.bat)
set(RHASH_WIN_DIST_FILES ${RHASH_WIN_BAT_FILES}
   ${CMAKE_CURRENT_LIST_DIR}/icon.ico)  
set(RHASH_EXE_SOURCES 
	${RHASH_SRC_DIR}/calc_sums.c 
	${RHASH_SRC_DIR}/hash_print.c
	${RHASH_SRC_DIR}/common_func.c
	${RHASH_SRC_DIR}/hash_update.c
	${RHASH_SRC_DIR}/file.c 
	${RHASH_SRC_DIR}/file_mask.c 
	${RHASH_SRC_DIR}/file_set.c 
	${RHASH_SRC_DIR}/find_file.c 
	${RHASH_SRC_DIR}/hash_check.c 
	${RHASH_SRC_DIR}/output.c 
	${RHASH_SRC_DIR}/parse_cmdline.c 
	${RHASH_SRC_DIR}/rhash_main.c 
	${RHASH_SRC_DIR}/win_utils.c)
set(RHASH_PO_DIR ${RHASH_SRC_DIR}/po)
set(RHASH_I18N_FILES
  ${RHASH_PO_DIR}/ca.po
  ${RHASH_PO_DIR}/de.po
  ${RHASH_PO_DIR}/en_AU.po
  ${RHASH_PO_DIR}/es.po 
  ${RHASH_PO_DIR}/fr.po 
  ${RHASH_PO_DIR}/gl.po 
  ${RHASH_PO_DIR}/it.po
  ${RHASH_PO_DIR}/ro.po
  ${RHASH_PO_DIR}/ru.po)
set(RHASH_SOURCE_RHASH_DIST_DIR ${RHASH_SRC_DIR}/dist)
set(RHASH_BUILD_DIST_DIR ${RHASH_BUILD_DIR}/dist)
set(RHASH_RHASH_SPECFILE_IN ${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.spec.in)
set(RHASH_SPECFILE     ${RHASH_BUILD_DIST_DIR}/rhash.spec)
set(RHASH_LIBRHASH_PC  ${RHASH_BUILD_DIST_DIR}/librhash.pc)
set(RHASH_OTHER_FILES  ${RHASH_SPECFILE}
   ${RHASH_SRC_DIR}/dist/rhashrc.sample)

set(RHASH_DEFAULT_SYMLINKS 
        sfv-hash
        tiger-hash
        tth-hash
        whirlpool-hash
        has160-hash
        gost-hash
        edonr256-hash
        edonr512-hash
        ed2k-link
        magnet-link)
file(MAKE_DIRECTORY ${RHASH_BUILD_DIST_DIR})

set(RHASH_ALL_FILES   
  ${SOURCES}
  ${HEADERS}
  ${LIBRHASH_FILES}
  ${RHASH_OTHER_FILES}
  ${RHASH_WIN_DIST_FILES}
  ${RHASH_I18N_FILES})  

#obtain version number from version.h

# from jsoncpp CMakeLists.txt
# Extract major, minor, patch from version text
# Parse a version string "X.Y.Z" and outputs
# version parts in ${OUPUT_PREFIX}_MAJOR, _MINOR, _PATCH.
# If parse succeeds then ${OUPUT_PREFIX}_FOUND is TRUE.
# Set variable named ${VAR_NAME} to value ${VALUE}
FUNCTION(set_using_dynamic_name VAR_NAME VALUE)
    SET( "${VAR_NAME}" "${VALUE}" PARENT_SCOPE)
ENDFUNCTION()

MACRO(jsoncpp_parse_version VERSION_TEXT OUPUT_PREFIX)
    SET(VERSION_REGEX "[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9_]+)?")
    IF( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
        STRING(REGEX MATCHALL "[0-9]+|-([A-Za-z0-9_]+)" VERSION_PARTS ${VERSION_TEXT})
        LIST(GET VERSION_PARTS 0 ${OUPUT_PREFIX}_MAJOR)
        LIST(GET VERSION_PARTS 1 ${OUPUT_PREFIX}_MINOR)
        LIST(GET VERSION_PARTS 2 ${OUPUT_PREFIX}_PATCH)
        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" TRUE )
    ELSE( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" FALSE )
    ENDIF()
ENDMACRO()

file(READ ${RHASH_SRC_DIR}/version.h VERSION_CONTENTS)
jsoncpp_parse_version( ${VERSION_CONTENTS} RHASH_VERSION )
IF(NOT RHASH_VERSION_FOUND)
    MESSAGE(FATAL_ERROR "Failed to parse version string properly. Expect X.Y.Z")
endif(NOT RHASH_VERSION_FOUND)

message(STATUS "RHash version:                    ${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}")

#cpack stuff
INCLUDE(InstallRequiredSystemLibraries)
SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Utility for computing hash sums and creating magnet links.")
SET(CPACK_PACKAGE_VENDOR "Aleksey Kravchenko")
SET(CPACK_PACKAGE_VERSION_MAJOR "${RHASH_VERSION_MAJOR}")
SET(CPACK_PACKAGE_VERSION_MINOR "${RHASH_VERSION_MINOR}")
SET(CPACK_PACKAGE_VERSION_PATCH "${RHASH_VERSION_PATCH}")
IF(WIN32 AND NOT UNIX)
  # There is a bug in NSI that does not handle full unix paths properly. Make
  # sure there is at least one set of four (4) backlasshes.
 if(CMAKE_RC_COMPILER)
    SET(CPACK_PACKAGE_ICON "${CMake_SOURCE_DIR}/\\\\rhash.exe")
  endif(CMAKE_RC_COMPILER)
  SET(CPACK_NSIS_MODIFY_PATH ON)
  SET(CPACK_NSIS_INSTALLED_ICON_NAME "bin\\\\rhash.exe")
  SET(CPACK_NSIS_DISPLAY_NAME "${CPACK_PACKAGE_INSTALL_DIRECTORY} Rhash")
  SET(CPACK_NSIS_HELP_LINK "http:\\\\\\\\rhash.sourceforge.net/")
  SET(CPACK_NSIS_URL_INFO_ABOUT "http:\\\\\\\\rhash.sourceforge.net/")
  SET(CPACK_NSIS_CONTACT "Aleksey Kravchenko <rhash.admin@gmail.com>")
ELSE(WIN32 AND NOT UNIX)
  SET(CPACK_STRIP_FILES "bin/${rhash_exe}")
  SET(CPACK_SOURCE_STRIP_FILES "")
ENDIF(WIN32 AND NOT UNIX)

include(CPack)

#library and program libary settings
set(RHASH_ADDITIONAL_LIBS "")
set(RHASH_ADDITIONAL_DIRS "")
set(RHASH_DEFINITIONS_FOR_ALL_TARGETS "")

if(RHASH_USE_OPENSSL)
  if (OPENSSL_FOUND)
    message(STATUS "OpenSSL Crypto Library:           ${OPENSSL_CRYPTO_LIBRARY}")
    message(STATUS "OpenSSL Crypto Includes:          ${OPENSSL_INCLUDE_DIR}")
    message(STATUS "OpenSSL Crypto Library Version:   ${OPENSSL_VERSION}")
    list(APPEND RHASH_ADDITIONAL_DIRS ${OPENSSL_INCLUDE_DIR})
    if (RHASH_OPENSSL_RUNTIME)
      set(RHASH_DEFINITIONS_FOR_ALL_TARGETS ${RHASH_DEFINITIONS_FOR_ALL_TARGETS} OPENSSL_RUNTIME)
    else()
      list(APPEND RHASH_ADDITIONAL_LIBS ${OPENSSL_CRYPTO_LIBRARY})
      set(RHASH_DEFINITIONS_FOR_ALL_TARGETS ${RHASH_DEFINITIONS_FOR_ALL_TARGETS} USE_OPENSSL)
      list(APPEND RHASH_LIB_DEPEND_LIBS ${OPENSSL_CRYPTO_LIBRARY})
    endif(RHASH_OPENSSL_RUNTIME)
  else()
      message(STATUS "OpenSSL Crypto Library:           Not Found")
  endif (OPENSSL_FOUND)
else()
  message(STATUS "OpenSSL Crypto Support:           Not Selected")
endif(RHASH_USE_OPENSSL)

if(RHASH_BUILD_EXE)
#make .rc file for .exe
  if(CMAKE_RC_COMPILER)
   file(COPY icon.ico DESTINATION ${RHASH_BUILD_DIR})
	set(RHASH_FILE_CONTENTS "id ICON \"icon.ico\"
1 VERSIONINFO
FILEVERSION     ${RHASH_VERSION_MAJOR},${RHASH_VERSION_MINOR},${RHASH_VERSION_PATCH},0
PRODUCTVERSION  ${RHASH_VERSION_MAJOR},${RHASH_VERSION_MINOR},${RHASH_VERSION_PATCH},0
BEGIN
  BLOCK \"StringFileInfo\"
  BEGIN
    BLOCK \"040904E4\"
    BEGIN
      VALUE \"CompanyName\", \"Aleksey Kravchenko <rhash.admin@gmail.com>\"
      VALUE \"FileDescription\", \"calculate/check CRC32, MD5, SHA1, GOST, TTH, BTIH or other hash sums.\"
      VALUE \"FileVersion\", \"${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}\"
      VALUE \"InternalName\", \"rhash\"
      VALUE \"LegalCopyright\", \"Copyright (c) 2005-2014 Aleksey Kravchenko <rhash.admin@gmail.com>\"
      VALUE \"OriginalFilename\", \"rhash${CMAKE_EXECUTABLE_SUFFIX}\"
      VALUE \"ProductName\", \"RHash\"
      VALUE \"ProductVersion\", \"${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}\"
    END
  END
  BLOCK \"VarFileInfo\"
  BEGIN
    VALUE \"Translation\", 0x409, 1252
  END
END")
     FILE(WRITE ${RHASH_BUILD_DIR}/rhash.rc "${RHASH_FILE_CONTENTS}")
  endif(CMAKE_RC_COMPILER)
  
  if (RHASH_USE_GETTEXT)
    if (Intl_FOUND)
      set(RHASH_EXE_DEFS "${RHASH_EXE_DEFS} USE_GETTEXT")
      list(APPEND RHASH_ADDITIONAL_DIRS ${Intl_INCLUDE_DIR})
	   if(Intl_LIBRARIES)
        list(APPEND RHASH_ADDITIONAL_LIBS ${Intl_LIBRARIES})
	   endif(Intl_LIBRARIES)
	   message(STATUS "Intl Includes:                    ${Intl_INCLUDE_DIR}")
	   # Intl_LIBRARIES may be empty on systems that don't require you to link to an additional library.
	   if(Intl_LIBRARIES) 
        message(STATUS "Intl Library:                     ${Intl_LIBRARIES}")
      elseif()
        message(STATUS "Intl Library:                     Not Required")	 
	   endif(Intl_LIBRARIES)
    else()
      message(STATUS "Intl Library:                     Not Found")	 
    endif(Intl_FOUND )
  else()
    message(STATUS "Intl Library Support:             Not Selected")	 
  endif(RHASH_USE_GETTEXT)
  if(CMAKE_RC_COMPILER)
    add_executable(rhash_exe ${RHASH_EXE_HEADERS} ${RHASH_EXE_SOURCES} ${RHASH_BUILD_DIR}/rhash.rc)
  else()
    add_executable(rhash_exe ${RHASH_EXE_HEADERS} ${RHASH_EXE_SOURCES})
  endif(CMAKE_RC_COMPILER)
  if(RHASH_ADDITIONAL_DIRS)
    target_include_directories(rhash_exe PRIVATE ${RHASH_ADDITIONAL_DIRS})
  endif(RHASH_ADDITIONAL_DIRS)
  
  if(RHASH_ADDITIONAL_LIBS)
    target_link_libraries(rhash_exe PUBLIC ${RHASH_ADDITIONAL_LIBS}) 
  endif(RHASH_ADDITIONAL_LIBS)
  set(RHASH_EXE_CONFDIR_MACRO "SYSCONFDIR=\"${CMAKE_INSTALL_FULL_SYSCONFDIR}\"")
  
  target_compile_definitions(rhash_exe PRIVATE ${RHASH_EXE_DEFS} ${RHASH_EXE_CONFDIR_MACRO})
  set_target_properties(rhash_exe PROPERTIES OUTPUT_NAME rhash)
  install(TARGETS rhash_exe
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
        PUBLIC_HEADER DESTINATION include)

  #Rhash man pages	
  install(FILES ${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)

  add_custom_target(symlinks)
  get_target_property(RASH_TARGET_NAME rhash_exe OUTPUT_NAME)

  foreach(RHASH_CURSYM ${RHASH_DEFAULT_SYMLINKS})
   # exe file symlink
    add_custom_command(OUTPUT ${RHASH_BUILD_DIR}/${RHASH_CURSYM}${CMAKE_EXECUTABLE_SUFFIX}
      DEPENDS rhash_exe
      COMMAND ${CMAKE_COMMAND} -E copy ${RHASH_BUILD_DIR}/${RASH_TARGET_NAME}${CMAKE_EXECUTABLE_SUFFIX} ${RHASH_BUILD_DIR}/${RHASH_CURSYM}${CMAKE_EXECUTABLE_SUFFIX})
    add_custom_target(exe_${RHASH_CURSYM} ALL DEPENDS ${RHASH_BUILD_DIR}/${RHASH_CURSYM}${CMAKE_EXECUTABLE_SUFFIX})
    install(FILES ${RHASH_BUILD_DIR}/${RHASH_CURSYM}${CMAKE_EXECUTABLE_SUFFIX} DESTINATION ${CMAKE_INSTALL_FULL_BINDIR})
    # man file symlinks
    add_custom_command(OUTPUT ${RHASH_BUILD_DIR}/${RHASH_CURSYM}.1
      COMMAND ${CMAKE_COMMAND} -E copy ${RHASH_SOURCE_RHASH_DIST_DIR}/${RASH_TARGET_NAME}.1 ${RHASH_BUILD_DIR}/${RHASH_CURSYM}.1)
    add_custom_target(man_${RHASH_CURSYM}.1 ALL DEPENDS ${RHASH_BUILD_DIR}/${RHASH_CURSYM}.1)
    install(FILES ${RHASH_BUILD_DIR}/${RHASH_CURSYM}.1 DESTINATION ${CMAKE_INSTALL_FULL_MANDIR}/man1)
  endforeach(RHASH_CURSYM)
  
  # Alternative Manpage forms
  
  find_program(SED sed)
  if(SED)
    message(STATUS "SED                               ${SED}")
    add_custom_command(POST_BUILD OUTPUT ${RHASH_BUILD_DIST_DIR}/rhash.1.win 
      COMMENT "Creating rhash.1.win" 
      COMMAND ${CMAKE_COMMAND} -D SED=${SED} -DSED_FILE=${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.1.win.sed -D MAN_FILE=${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.1 -DWIN_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.win -P ${CMAKE_CURRENT_LIST_DIR}/make_win_man.cmake)
    add_custom_target(win_doc ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.win)
    install(FILES ${RHASH_BUILD_DIST_DIR}/rhash.1.win DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
  else()
    message(STATUS "SED                               Not Found") 
  endif(SED)

  find_program(RMAN rman)
  if(RMAN)
    message(STATUS "Polyglotman (rman)                ${RMAN}")
    add_custom_command(POST_BUILD OUTPUT ${RHASH_BUILD_DIST_DIR}/rhash.1.html COMMENT "Creating rhash.1.html" 
      COMMAND ${CMAKE_COMMAND} -D RMAN=${RMAN} -D MAN_FILE=${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.1 -DHTML_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.html -P ${CMAKE_CURRENT_LIST_DIR}/make_html.cmake)
    install(FILES ${RHASH_BUILD_DIST_DIR}/rhash.1.html DESTINATION ${CMAKE_INSTALL_DOCDIR}/html)
    if(SED)
      add_custom_command(POST_BUILD OUTPUT ${RHASH_BUILD_DIST_DIR}/rhash.1.win.html 
        DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.win 
        COMMENT "Creating rhash.1.win.html" 
        COMMAND ${CMAKE_COMMAND} -D RMAN=${RMAN} -D MAN_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.win -DHTML_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.win.html -P ${CMAKE_CURRENT_LIST_DIR}/make_html.cmake)
      install(FILES ${RHASH_BUILD_DIST_DIR}/rhash.1.win.html DESTINATION ${CMAKE_INSTALL_DOCDIR}/html)
	   add_custom_target(html_doc ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.html ${RHASH_BUILD_DIST_DIR}/rhash.1.win.html)
    else()
      add_custom_target(html_doc ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.html)
    endif(SED)  
  else()
    message(STATUS "Polyglotman (rman)                Not Found")
  endif(RMAN)

  find_program(GROFF groff)
  if(GROFF)
    #dist/rhash.1.txt: dist/rhash.1
    #	-which groff &>/dev/null && (groff -t -e -mandoc -Tascii dist/rhash.1 | sed -e 's/.\[[0-9]*m//g' > $@)
    message(STATUS "groff                             ${GROFF}")
    add_custom_command(POST_BUILD OUTPUT ${RHASH_BUILD_DIST_DIR}/rhash.1.txt COMMENT "Creating rhash.1.txt" 
      COMMAND ${CMAKE_COMMAND} -D GROFF=${GROFF} -D MAN_FILE=${RHASH_SOURCE_RHASH_DIST_DIR}/rhash.1 -DTXT_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.txt -P ${CMAKE_CURRENT_LIST_DIR}/make_txt.cmake)
    install(FILES ${RHASH_BUILD_DIST_DIR}/rhash.1.txt DESTINATION ${CMAKE_INSTALL_DOCDIR}/txt)
    if(SED)
      add_custom_command(POST_BUILD OUTPUT ${RHASH_BUILD_DIST_DIR}/rhash.1.win.txt D
        EPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.win COMMENT "Creating rhash.1.win.txt" 
        COMMAND ${CMAKE_COMMAND} -D GROFF=${GROFF} -D MAN_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.win -DTXT_FILE=${RHASH_BUILD_DIST_DIR}/rhash.1.win.txt -P ${CMAKE_CURRENT_LIST_DIR}/make_txt.cmake)
      install(FILES ${RHASH_BUILD_DIST_DIR}/rhash.1.win.txt DESTINATION ${CMAKE_INSTALL_DOCDIR}/txt)
      add_custom_target(txt_doc ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.txt ${RHASH_BUILD_DIST_DIR}/rhash.1.win.txt)
    else()
      add_custom_target(txt_doc ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhash.1.txt ${RHASH_BUILD_DIST_DIR}/rhash.1.win.txt)
    endif(SED)
  else()
     message(STATUS "groff                             Not Found")
  endif(GROFF)

  #rhashrc
  add_custom_command(OUTPUT ${RHASH_BUILD_DIST_DIR}/rhashrc COMMENT "Creating rhashrc" 
    COMMAND ${CMAKE_COMMAND} -D SOURCE_FILE=${RHASH_SOURCE_RHASH_DIST_DIR}/rhashrc.sample -DDEST_FILE=${RHASH_BUILD_DIST_DIR}/rhashrc -P ${CMAKE_CURRENT_LIST_DIR}/stripCR.cmake)
  add_custom_target(system-conf ALL DEPENDS ${RHASH_BUILD_DIST_DIR}/rhashrc)
  install(FILES ${RHASH_BUILD_DIST_DIR}/rhashrc DESTINATION ${CMAKE_INSTALL_SYSCONFDIR})
  #While this is a misc. file, it only is applicable if the executable is installed.
  if(RHASH_INCLUDE_OTHER_FILES)
    install(FILES ${RHASH_SOURCE_RHASH_DIST_DIR}/rhashrc.sample DESTINATION ${CMAKE_INSTALL_DOCDIR})
  endif(RHASH_INCLUDE_OTHER_FILES)

  #Gettext support
  if (RHASH_USE_GETTEXT)
    if(GETTEXT_FOUND)
		message(STATUS "Gettext version                   ${GETTEXT_VERSION_STRING}")	
	   message(STATUS "Gettext     (msgmerge)            ${GETTEXT_MSGMERGE_EXECUTABLE}")    
      message(STATUS "Gettext     (msgfmt)              ${GETTEXT_MSGFMT_EXECUTABLE}")    
      foreach(RHASH_PO_FILE ${RHASH_I18N_FILES})
        get_filename_component(CUR_LANG ${RHASH_PO_FILE} NAME_WE)
        GETTEXT_PROCESS_PO_FILES(${CUR_LANG} ALL INSTALL_DESTINATION ${CMAKE_INSTALL_FULL_LOCALEDIR} RHASH_PO_FILES ${RHASH_PO_FILE})
      endforeach(RHASH_PO_FILE)
	 else()
      message(STATUS "Gettext:                        Not Found")    
    endif(GETTEXT_FOUND)
  else()
    message(STATUS "i18n support with Gettext:        Not Selected")    
  endif(RHASH_USE_GETTEXT)
endif(RHASH_BUILD_EXE)

set(RHASH_LIB_DEPEND_LIBS "${RHASH_LIB_DEPEND_LIBS};${CMAKE_DL_LIBS}")

if(BUILD_SHARED_LIBS)
   if(CMAKE_RC_COMPILER)
  # Make .rc file  
  		set(RHASH_FILE_CONTENTS "1 VERSIONINFO
FILEVERSION     ${RHASH_VERSION_MAJOR},${RHASH_VERSION_MINOR},${RHASH_VERSION_PATCH},0
PRODUCTVERSION  ${RHASH_VERSION_MAJOR},${RHASH_VERSION_MINOR},${RHASH_VERSION_PATCH},0
BEGIN
  BLOCK \"StringFileInfo\"
  BEGIN
    BLOCK \"040904E4\"
    BEGIN
      VALUE \"CompanyName\", \"Aleksey Kravchenko <rhash.admin@gmail.com>\"
      VALUE \"FileDescription\", \"LibRHash shared library\"
      VALUE \"FileVersion\", \"${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}\"
      VALUE \"InternalName\", \"${CMAKE_SHARED_MODULE_PREFIX}rhash\"
      VALUE \"LegalCopyright\", \"Copyright (c) 2005-2014 Aleksey Kravchenko <rhash.admin@gmail.com>\"
      VALUE \"OriginalFilename\", \"${CMAKE_SHARED_MODULE_PREFIX}rhash${CMAKE_SHARED_LIBRARY_SUFFIX}\"
      VALUE \"ProductName\", \"RHash\"
      VALUE \"ProductVersion\", \"${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}\"
    END
  END
  BLOCK \"VarFileInfo\"
  BEGIN
    VALUE \"Translation\", 0x409, 1252
  END
END")
     FILE(WRITE ${RHASH_BUILD_DIR}/librhash.rc "${RHASH_FILE_CONTENTS}")
	 
     add_library(rhash_lib SHARED ${RHASH_LIB_SOURCES} ${RHASH_BUILD_DIR}/librhash.rc)
   else()
     add_library(rhash_lib SHARED ${RHASH_LIB_SOURCES})
	endif(CMAKE_RC_COMPILER)
    set_target_properties(rhash_lib PROPERTIES OUTPUT_NAME rhash)
	if (WIN32 OR CYGWIN OR MSYS OR WINCE)
      set_target_properties(rhash_lib PROPERTIES PUBLIC_HEADER "${RHASH_LIB_PUBLIC_HEADERS}")   
	else()
      set_target_properties(rhash_lib PROPERTIES PUBLIC_HEADER "${RHASH_LIB_PUBLIC_HEADERS}" SOVERSION ${SOVERSION})   
	endif (WIN32 OR CYGWIN OR MSYS OR WINCE)
    target_compile_definitions(rhash_lib PRIVATE ${RHASH_DEFINITIONS_FOR_ALL_TARGETS} RHASH_EXPORTS )
    target_link_libraries(rhash_lib PUBLIC ${RHASH_ADDITIONAL_LIBS} ${CMAKE_DL_LIBS}) 
	install(TARGETS rhash_lib
      RUNTIME DESTINATION bin
      LIBRARY DESTINATION lib
      ARCHIVE DESTINATION lib
      PUBLIC_HEADER DESTINATION include)
    add_executable(test_shared_exe ${RHASH_LIB_TEXT_SOURCES} )
    target_link_libraries(test_shared_exe PUBLIC rhash_lib)
    set_target_properties(test_shared_exe PROPERTIES OUTPUT_NAME test_shared)
	 add_test(NAME test_shared_library COMMAND $<TARGET_FILE:test_shared_exe>)
	 if(RHASH_BUILD_EXE)
      target_link_libraries(rhash_exe PUBLIC rhash_lib)
	 endif(RHASH_BUILD_EXE)
endif(BUILD_SHARED_LIBS)

if(BUILD_STATIC_LIBS)
    add_library(rhash_lib_static STATIC ${RHASH_LIB_SOURCES})
    set_target_properties(rhash_lib_static PROPERTIES OUTPUT_NAME rhash)
    if (WIN32 OR CYGWIN OR MSYS OR WINCE)
           set_target_properties(rhash_lib_static PROPERTIES PUBLIC_HEADER "${RHASH_LIB_PUBLIC_HEADERS}")   
    else()
           set_target_properties(rhash_lib_static PROPERTIES PUBLIC_HEADER "${RHASH_LIB_PUBLIC_HEADERS}" SOVERSION ${SOVERSION})   
    endif (WIN32 OR CYGWIN OR MSYS OR WINCE)
    target_compile_definitions(rhash_lib_static PRIVATE ${RHASH_DEFINITIONS_FOR_ALL_TARGETS})
    target_link_libraries(rhash_lib_static PUBLIC "${RHASH_LIB_DEPEND_LIBS}")
    install(TARGETS rhash_lib_static
      RUNTIME DESTINATION bin
      LIBRARY DESTINATION lib
      ARCHIVE DESTINATION lib
      PUBLIC_HEADER DESTINATION include)
	 if (RHASH_BUILD_EXE)
      if (NOT(BUILD_SHARED_LIBS))
         target_link_libraries(rhash_exe PUBLIC rhash_lib_static)
      else()
         target_link_libraries(rhash_exe PUBLIC rhash_lib)
      endif(NOT(BUILD_SHARED_LIBS))
	 endif(RHASH_BUILD_EXE)
    add_executable(test_exe_static ${RHASH_LIB_TEXT_SOURCES})
    target_link_libraries(test_exe_static PUBLIC rhash_lib_static)
	add_test(NAME test_static_library COMMAND $<TARGET_FILE:test_exe_static> )
    set_target_properties(test_exe_static PROPERTIES OUTPUT_NAME test_static)
endif(BUILD_STATIC_LIBS)

#Make pkg-config
set(PC_EXC "${CMAKE_INSTALL_PREFIX}")
set(PC_INC "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
set(PC_LIB "${CMAKE_INSTALL_FULL_LIBDIR}")
if("${PC_EXC}" STREQUAL "${CMAKE_INSTALL_PREFIX}")
    set(PC_EXC "\$\{prefix\}")
endif()
if ("${PC_INC}" STREQUAL "${CMAKE_INSTALL_PREFIX}/include")
    set(PC_INC "\$\{prefix\}/include")
endif()
if ("${PC_LIB}" STREQUAL "${CMAKE_INSTALL_PREFIX}/lib")
    set(PC_LIB "\$\{exec_prefix\}/lib")
endif()
  
if(RHASH_WITH_PKGCONFIG_SUPPORT)
  # This stuff is necessary to ensure that the dependency list
  # in our .pc file is in the proper format
  set(RHASH_PKGCONF_RHASH_DEPS "")
  foreach(RHASH_LIB_DEP ${RHASH_LIB_DEPEND_LIBS})
    set(RHASH_PKGCONF_RHASH_DEPS "${RHASH_PKGCONF_RHASH_DEPS} -l${RHASH_LIB_DEP}")
  endforeach(RHASH_LIB_DEP)

  set(PKGCONFIG_CONTENTS "prefix=${CMAKE_INSTALL_PREFIX}\r
exec_prefix=${PC_EXC}
libdir=${PC_LIB}
includedir=${PC_INC}

Name: librash
Description: LibRHash shared library
Version: ${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}
Cflags: -I\$\{includedir\}
Libs: -L\${libdir\} -lrhash
Libs.private: ${RHASH_PKGCONF_RHASH_DEPS}
")
  file(WRITE ${RHASH_LIBRHASH_PC} ${PKGCONFIG_CONTENTS})
  install(FILES ${RHASH_LIBRHASH_PC} DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
endif(RHASH_WITH_PKGCONFIG_SUPPORT)

if(RHASH_INCLUDE_OTHER_FILES)
  # rpm spec file
  file(READ "${RHASH_RHASH_SPECFILE_IN}" RHASH_FILE_CONTENTS)
  string(REPLACE "@VERSION@" "${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH}" RHASH_FILE_CONTENTS "${RHASH_FILE_CONTENTS}")
  file(WRITE ${RHASH_SPECFILE} "${RHASH_FILE_CONTENTS}")
  install(FILES ${RHASH_SPECFILE} DESTINATION ${CMAKE_INSTALL_DOCDIR})
endif(RHASH_INCLUDE_OTHER_FILES)

if(RHASH_BUILD_LIB_DOCS)
#Note that we use this to ensure that the Doxyfile has the appropriate properly formatted settings
#including _NOT_FOUND messages.
  set(RHASH_HAVE_DOT "NO")  
#This is somewhat messy because I couldn't figure out how to use the FindDoxygen module using FindPackage
#and some stuff might not be available in older versions of CMake.  I also wanted to provide Doxygen with as
#much of it's helper program functionality as I could.  Some I had to do manually for compatability with older
#cmake versions.
  if(DOXYGEN_FOUND)
    message(STATUS "doxygen                           ${DOXYGEN_EXECUTABLE}")
    message(STATUS "doxygen version                   ${DOXYGEN_VERSION}")
    #based from: https://vicrucann.github.io/tutorials/quick-cmake-doxygen/
    # set input and output files
    set(RHASH_DOXYGEN_IN ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in)
	 if(DOXYGEN_DOT_FOUND)
	   set(RHASH_HAVE_DOT "YES")
	   set(RHASH_DOT_EXECUTABLE ${DOXYGEN_DOT_EXECUTABLE})
      message(STATUS "Graphviz    (dot)                 ${DOXYGEN_DOT_EXECUTABLE}")	
	 else()
      set(RHASH_HAVE_DOT "NO")
      unset(RHASH_DOT_EXECUTABLE)
	   message(STATUS "Graphviz    (dot)                 Not Found")	
	 endif(DOXYGEN_DOT_FOUND)
    set(RHASH_DOXYGEN_OUT ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile)

	 # Optional - use mscgen
	 find_program(MSCGEN mscgen)
	 if(MSCGEN)
       message(STATUS "mscgen                            ${MSCGEN}")		
	   	 # Doxygen will use this dir to find mscgen   
	    get_filename_component(RHASH_MSCGEN_PATH ${MSCGEN} DIRECTORY)
	 else()
       message(STATUS "mscgen                            Not Found")	
	    unset(RHASH_MSCGEN_PATH)	   
    endif(MSCGEN)

	 # Optional - use dia
	 find_program(DIA dia)
	 if(DIA)
       message(STATUS "dia                               ${DIA}")		
	   # Doxygen will use this dir to find mscgen   
	   get_filename_component(RHASH_DIA_PATH ${DIA} DIRECTORY)
	 else()
       message(STATUS "dia                               Not Found")		
	    unset(RHASH_DIA_PATH)
    endif(DIA)
    # request to configure the file
    configure_file(${RHASH_DOXYGEN_IN} ${RHASH_DOXYGEN_OUT} @ONLY)
    # note the option ALL which allows to build the docs together with the application
    add_custom_target( doc_doxygen ALL
        COMMAND ${DOXYGEN_EXECUTABLE} ${RHASH_DOXYGEN_OUT}
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT "Generating API documentation with Doxygen"
        VERBATIM )
     install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc_doxygen/html DESTINATION ${CMAKE_INSTALL_DOCDIR}) 
	  install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc_doxygen/man/ DESTINATION ${CMAKE_INSTALL_MANDIR}) 
  else()
	  message(STATUS "doxygen                           Not Found")		
  endif(DOXYGEN_FOUND)
endif(RHASH_BUILD_LIB_DOCS)

if(RHASH_INCLUDE_WINDIST_FILES)
  # RHASH_WIN_DIST_FILES
  foreach (RHASH_CURDIST ${RHASH_WIN_DIST_FILES})
    install(FILES ${RHASH_CURDIST} DESTINATION ${CMAKE_INSTALL_FULL_DOCDIR})
  endforeach(RHASH_CURDIST)
  # Win32 .bat files
  if(WIN32)
    foreach (RHASH_CURDIST ${RHASH_WIN_BAT_FILES})
      install(FILES ${RHASH_CURDIST} DESTINATION ${CMAKE_INSTALL_FULL_BINDIR})
    endforeach(RHASH_CURDIST)
  endif(WIN32)
endif(RHASH_INCLUDE_WINDIST_FILES)

# bindings
add_custom_command(PRE_BUILD OUTPUT bindings
  COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_SOURCE_DIR}/../bindings ${RHASH_BUILD_DIST_DIR}/bindings)
add_custom_command(PRE_BUILD OUTPUT bindings/version.properties
  COMMAND ${CMAKE_COMMAND} -D VERSION=${RHASH_VERSION_MAJOR}.${RHASH_VERSION_MINOR}.${RHASH_VERSION_PATCH} 
    -DVERSION_PROP_FILE=${RHASH_BUILD_DIST_DIR}/bindings/version.properties 
    -P ${CMAKE_CURRENT_LIST_DIR}/make_version_properties.cmake)
add_custom_target(bindings_dir ALL DEPENDS bindings bindings/version.properties)

if(RHASH_BUILD_EXE)
 set(RHASH_TEST_RHASH_EXE "$<TARGET_FILE:rhash_exe>")
 set(RHASH_TMPDIR "${CMAKE_BINARY_DIR}/tests")
set(RHASH_TEST_DATA_FILE "test1K.data")
set(RHASH_BIN_DATA_FILE "binary.data")
set(CREATE_DIRECTORY ${CMAKE_BINARY_DIR}/tests)
#These two files have to be copied to the temp dir so links can work
#in our tests.
file(COPY "${RHASH_SRC_DIR}/tests/test1K.data" DESTINATION "${RHASH_TMPDIR}")
file(COPY "${RHASH_SRC_DIR}/tests/test1K.data" DESTINATION ${CMAKE_SOURCE_DIR}/tests)
file(COPY "${CMAKE_SOURCE_DIR}/tests/binary.data" DESTINATION "${RHASH_TMPDIR}")

 add_test(NAME test_string1              WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_string1.cmake)

add_test(NAME test_with_1Kb_data_file   WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_with_1Kb_data_file.cmake)

add_test(NAME test_handling_empty_files WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_handling_empty_files.cmake)

add_test(NAME test_default_format       WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_default_format.cmake)

add_test(NAME test_x_b_B_modifiers      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_x_b_B_modifiers.cmake)

#This one requires RHASH_BIN_DATA_FILE isntead of RHASH_TEST_DATA_FILE
add_test(NAME test_special_characters   WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_BIN_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_special_characters.cmake)

if   (RHASH_TESTS_OPT_FULL)
add_test(NAME test_all_hash_options     WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_ignoring_of_log_files.cmake)

endif(RHASH_TESTS_OPT_FULL)

add_test(NAME test_eDonkey_link         WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_eDonkey_link.cmake)

add_test(NAME test_checking_all_hashes  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_checking_all_hashes.cmake)

add_test(NAME test_checking_magnet_link WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_checking_magnet_link.cmake)

add_test(NAME test_bsd_format_checking  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_bsd_format_checking.cmake)

add_test(NAME test_checking_w_o_filename WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_checking_w_o_filename.cmake)

add_test(NAME test_checking_embedded_crc WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_checking_embedded_crc.cmake)

add_test(NAME test_wrong_sums_detection WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_wrong_sums_detection.cmake)

add_test(NAME test_accept_options WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_accept_options.cmake)

add_test(NAME test_ignoring_of_log_files WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_ignoring_of_log_files.cmake)

add_test(NAME test_creating_torrent_file WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_creating_torrent_file.cmake)

add_test(NAME test_exit_code WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/tests 
COMMAND ${CMAKE_COMMAND} -DRHASH=${RHASH_TEST_RHASH_EXE} -DTEST_DATA_FILE=${RHASH_TEST_DATA_FILE} -DTMPDIR=${RHASH_TMPDIR} -P ${CMAKE_SOURCE_DIR}/tests/test_exit_code.cmake)

endif(RHASH_BUILD_EXE)

  #dump GNUInstallDirs vars
message(STATUS "CMAKE_INSTALL_FULL_BINDIR         ${CMAKE_INSTALL_FULL_BINDIR}")
message(STATUS "CMAKE_INSTALL_FULL_SBINDIR        ${CMAKE_INSTALL_FULL_SBINDIR}")
message(STATUS "CMAKE_INSTALL_FULL_LIBEXECDIR     ${CMAKE_INSTALL_FULL_LIBEXECDIR}")
message(STATUS "CMAKE_INSTALL_FULL_SYSCONFDIR     ${CMAKE_INSTALL_FULL_SYSCONFDIR}")
message(STATUS "CMAKE_INSTALL_FULL_SHAREDSTATEDIR ${CMAKE_INSTALL_FULL_SHAREDSTATEDIR}")
message(STATUS "CMAKE_INSTALL_FULL_LOCALSTATEDIR  ${CMAKE_INSTALL_FULL_LOCALSTATEDIR}")
message(STATUS "CMAKE_INSTALL_FULL_LIBDIR         ${CMAKE_INSTALL_FULL_LIBDIR}")
message(STATUS "CMAKE_INSTALL_FULL_INCLUDEDIR     ${CMAKE_INSTALL_FULL_INCLUDEDIR}")
message(STATUS "CMAKE_INSTALL_FULL_OLDINCLUDEDIR  ${CMAKE_INSTALL_FULL_OLDINCLUDEDIR}")
message(STATUS "CMAKE_INSTALL_FULL_DATAROOTDIR    ${CMAKE_INSTALL_FULL_DATAROOTDIR}")
message(STATUS "CMAKE_INSTALL_FULL_DATADIR        ${CMAKE_INSTALL_FULL_DATADIR}")
message(STATUS "CMAKE_INSTALL_FULL_INCLUDEDIR     ${CMAKE_INSTALL_FULL_INFODIR}")
message(STATUS "CMAKE_INSTALL_FULL_LOCALEDIR      ${CMAKE_INSTALL_FULL_LOCALEDIR}")
message(STATUS "CMAKE_INSTALL_FULL_MANDIR         ${CMAKE_INSTALL_FULL_MANDIR}")
message(STATUS "CMAKE_INSTALL_FULL_DOCDIR         ${CMAKE_INSTALL_FULL_DOCDIR}")